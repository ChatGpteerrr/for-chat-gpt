local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer

local function attachGuiToPlayer(gui)
    gui.ResetOnSpawn = false

    if type(syn) == "table" and syn.protect_gui then
        pcall(function()
            syn.protect_gui(gui)
        end)

        if gethui then
            gui.Parent = gethui()
            return
        end
    end

    if gethui then
        gui.Parent = gethui()
    else
        local success, playerGui = pcall(function()
            return localPlayer:WaitForChild("PlayerGui")
        end)

        if success and playerGui then
            gui.Parent = playerGui
        else
            gui.Parent = game:GetService("CoreGui")
        end
    end
end

local currentCharacter = nil
local currentHumanoid = nil
local currentRootPart = nil

local lastDashTime = 0
local dashCooldownSeconds = 0.35
local stickDashEnabled = true
local isCooldownRunning = false
local cooldownDuration = 7
local dashRecoveryExtraDelay = 0.3

local function getNearestCharacterModel()
    local nearestModel = nil
    local nearestDistance = math.huge

    if not currentRootPart then
        return nil
    end

    for _, descendant in pairs(workspace:GetDescendants()) do
        local chosenModel = nearestModel
        local chosenDistance = nearestDistance

        if descendant:IsA("Model") and descendant:FindFirstChild("HumanoidRootPart") and descendant ~= currentCharacter then
            local success, distance = pcall(function()
                return (currentRootPart.Position - descendant.HumanoidRootPart.Position).Magnitude
            end)

            if success and distance and distance < nearestDistance then
                chosenModel = descendant
                chosenDistance = distance
            end
        end

        nearestModel = chosenModel
        nearestDistance = chosenDistance
    end

    return nearestModel
end

local function fireDashRemoteEvents()
    task.delay(0.1, function()
        pcall(function()
            local dashPayload = {
                {
                    Dash = Enum.KeyCode.W,
                    Key = Enum.KeyCode.Q,
                    Goal = "KeyPress"
                }
            }

            if currentCharacter and currentCharacter:FindFirstChild("Communicate") then
                currentCharacter.Communicate:FireServer(unpack(dashPayload))
            end
        end)
    end)

    local function findNilInstanceByNameAndClass(instanceName, className)
        if type(getnilinstances) ~= "function" then
            return nil
        end

        for _, inst in pairs(getnilinstances()) do
            if inst.ClassName == className and inst.Name == instanceName then
                return inst
            end
        end
    end

    pcall(function()
        local deleteBodyVelocityPayload = {
            {
                Goal = "delete bv",
                BV = findNilInstanceByNameAndClass("moveme", "BodyVelocity")
            }
        }

        if currentCharacter and currentCharacter:FindFirstChild("Communicate") then
            currentCharacter.Communicate:FireServer(unpack(deleteBodyVelocityPayload))
        end
    end)
end

local function performStickDash()
    if not (currentCharacter and currentHumanoid and currentRootPart) then
        return
    end

    local targetModel = getNearestCharacterModel()
    if not targetModel then
        return
    end

    local targetRootPart = targetModel:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then
        return
    end

    local savedHumanoidState = {}

    pcall(function()
        savedHumanoidState.WalkSpeed = currentHumanoid.WalkSpeed
        savedHumanoidState.JumpPower = currentHumanoid.JumpPower
        savedHumanoidState.PlatformStand = currentHumanoid.PlatformStand

        if currentHumanoid:GetAttribute("AutoRotate") ~= nil then
            savedHumanoidState.AutoRotate = currentHumanoid.AutoRotate
        else
            pcall(function()
                savedHumanoidState.AutoRotate = currentHumanoid.AutoRotate
            end)
        end
    end)

    local freezeHeartbeatConnection = nil

    local function freezeCharacter()
        if currentHumanoid and currentRootPart and currentCharacter then
            pcall(function()
                currentHumanoid.WalkSpeed = 0
                currentHumanoid.JumpPower = 0
                currentHumanoid.PlatformStand = true

                pcall(function()
                    currentHumanoid.AutoRotate = false
                end)

                if currentRootPart then
                    currentRootPart.Velocity = Vector3.new(0, 0, 0)
                    currentRootPart.RotVelocity = Vector3.new(0, 0, 0)
                end
            end)

            for _, descendant in pairs(currentCharacter:GetDescendants()) do
                local className = descendant.ClassName

                if className == "BodyVelocity"
                    or className == "BodyPosition"
                    or className == "BodyGyro"
                    or className == "VectorForce"
                    or className == "AlignPosition"
                    or className == "AlignOrientation"
                    or className == "LinearVelocity"
                    or className == "AngularVelocity" then

                    pcall(function()
                        descendant:Destroy()
                    end)
                end
            end

            freezeHeartbeatConnection = RunService.Heartbeat:Connect(function()
                if currentRootPart then
                    pcall(function()
                        currentRootPart.Velocity = Vector3.new(0, 0, 0)
                        currentRootPart.RotVelocity = Vector3.new(0, 0, 0)
                    end)
                end

                if currentHumanoid and currentHumanoid.WalkSpeed then
                    pcall(function()
                        currentHumanoid.WalkSpeed = 0
                    end)
                end
            end)
        end
    end

    local function restoreCharacter()
        if freezeHeartbeatConnection and freezeHeartbeatConnection.Disconnect then
            pcall(function()
                freezeHeartbeatConnection:Disconnect()
            end)
        end

        pcall(function()
            if currentHumanoid then
                currentHumanoid.WalkSpeed = savedHumanoidState.WalkSpeed or 16
                currentHumanoid.JumpPower = savedHumanoidState.JumpPower or 50
                currentHumanoid.PlatformStand = savedHumanoidState.PlatformStand or false

                if savedHumanoidState.AutoRotate ~= nil then
                    pcall(function()
                        currentHumanoid.AutoRotate = savedHumanoidState.AutoRotate
                    end)
                end
            end

            if currentRootPart then
                pcall(function()
                    currentRootPart.Velocity = Vector3.new(0, 0, 0)
                    currentRootPart.RotVelocity = Vector3.new(0, 0, 0)
                end)
            end
        end)
    end

    freezeCharacter()

    pcall(function()
        currentHumanoid:ChangeState(Enum.HumanoidStateType.Physics)
    end)

    currentRootPart.CFrame = currentRootPart.CFrame * CFrame.Angles(math.rad(85), 0, 0)

    local stickStartTime = tick()
    local followConnection = nil

    followConnection = RunService.Heartbeat:Connect(function()
        if tick() - stickStartTime < 0.7 then
            local success, newCFrame = pcall(function()
                return CFrame.new(targetRootPart.Position - targetRootPart.CFrame.LookVector * 0.3)
                    * CFrame.Angles(math.rad(85), 0, 0)
            end)

            if success and newCFrame then
                currentRootPart.CFrame = newCFrame
            end
        else
            followConnection:Disconnect()
        end
    end)

    task.delay(0.18, function()
        pcall(fireDashRemoteEvents)
    end)

    task.delay(0.3, function()
        pcall(function()
            currentHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end)
    end)

    local restoreDelay = 0.7 + dashRecoveryExtraDelay

    task.delay(restoreDelay, function()
        pcall(restoreCharacter)
    end)
end

local mainGui = Instance.new("ScreenGui")
mainGui.Name = "Merebennie_StickDashGui"
mainGui.IgnoreGuiInset = true
attachGuiToPlayer(mainGui)

local toggleButton = Instance.new("TextButton")
toggleButton.Name = "StickDashToggle"
toggleButton.Size = UDim2.new(0, 45, 0, 45)
toggleButton.Position = UDim2.new(0.4, 0, 0.8, 0)
toggleButton.Text = "On"
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 18
toggleButton.TextScaled = true
toggleButton.BackgroundColor3 = Color3.fromRGB(66, 150, 255)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Parent = mainGui
toggleButton.ZIndex = 9999
toggleButton.Active = true

Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 8)

local toggleStroke = Instance.new("UIStroke", toggleButton)
toggleStroke.Thickness = 1
toggleStroke.Transparency = 0.25

pcall(function()
    if Font and Font.new then
        toggleButton.FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json")
    end
end)

local toggleSound = Instance.new("Sound")
toggleSound.Name = "ToggleSound"
toggleSound.SoundId = "rbxassetid://5852470908"
toggleSound.Parent = toggleButton
toggleSound.Volume = 1

local originalToggleSize = toggleButton.Size

local pressDownTween = TweenService:Create(
    toggleButton,
    TweenInfo.new(0.06, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
    {
        Size = UDim2.new(
            originalToggleSize.X.Scale,
            math.floor(originalToggleSize.X.Offset * 0.88),
            originalToggleSize.Y.Scale,
            math.floor(originalToggleSize.Y.Offset * 0.88)
        )
    }
)

local pressUpTween = TweenService:Create(
    toggleButton,
    TweenInfo.new(0.12, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out),
    {
        Size = originalToggleSize
    }
)

local isToggleBeingDragged = nil
local toggleDragInput = nil
local toggleDragStart = nil
local toggleStartPosition = nil

toggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then

        pcall(function()
            pressDownTween:Play()
            if toggleSound and toggleSound.Play then
                toggleSound:Play()
            end
        end)

        isToggleBeingDragged = true
        toggleDragStart = input.Position
        toggleStartPosition = toggleButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isToggleBeingDragged = false
                pcall(function()
                    pressUpTween:Play()
                end)
            end
        end)
    end
end)

toggleButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement
        or input.UserInputType == Enum.UserInputType.Touch then

        toggleDragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == toggleDragInput and isToggleBeingDragged and toggleStartPosition then
        local delta = input.Position - toggleDragStart
        toggleButton.Position = UDim2.new(
            toggleStartPosition.X.Scale,
            toggleStartPosition.X.Offset + delta.X,
            toggleStartPosition.Y.Scale,
            toggleStartPosition.Y.Offset + delta.Y
        )
    end
end)

toggleButton.MouseButton1Click:Connect(function()
    stickDashEnabled = not stickDashEnabled

    if stickDashEnabled then
        toggleButton.Text = "On"
        toggleButton.BackgroundColor3 = Color3.fromRGB(66, 150, 255)
    else
        toggleButton.Text = "Off"
        toggleButton.BackgroundColor3 = Color3.fromRGB(130, 130, 130)
    end

    pcall(function()
        pressUpTween:Play()
    end)

    pcall(function()
        if toggleSound and toggleSound.Play then
            toggleSound:Play()
        end
    end)
end)

local cooldownFrame = Instance.new("Frame")
cooldownFrame.Name = "MerckCooldown"
cooldownFrame.Size = UDim2.new(0, 140, 0, 32)
cooldownFrame.Position = UDim2.new(0, 8, 1, -48)
cooldownFrame.AnchorPoint = Vector2.new(0, 0)
cooldownFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
cooldownFrame.BackgroundTransparency = 0.25
cooldownFrame.Visible = false
cooldownFrame.Parent = mainGui
cooldownFrame.ZIndex = 9998
cooldownFrame.Active = true

Instance.new("UICorner", cooldownFrame).CornerRadius = UDim.new(0, 14)

local cooldownStroke = Instance.new("UIStroke", cooldownFrame)
cooldownStroke.Thickness = 1
cooldownStroke.Transparency = 0.35

local cooldownLabel = Instance.new("TextLabel")
cooldownLabel.Name = "CooldownText"
cooldownLabel.Size = UDim2.new(1, -12, 1, 0)
cooldownLabel.Position = UDim2.new(0, 8, 0, 0)
cooldownLabel.BackgroundTransparency = 1
cooldownLabel.Text = "Kiba V3 : 0.0s"
cooldownLabel.TextColor3 = Color3.new(1, 1, 1)
cooldownLabel.Font = Enum.Font.GothamBold
cooldownLabel.TextSize = 14
cooldownLabel.TextXAlignment = Enum.TextXAlignment.Left
cooldownLabel.Parent = cooldownFrame
cooldownLabel.ZIndex = 9999

local cooldownPulseTween = TweenService:Create(
    cooldownFrame,
    TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
    {
        BackgroundTransparency = 0.18
    }
)

local isCooldownTweenPlaying = false

local function startCooldown(duration)
    if isCooldownRunning then
        return
    end

    isCooldownRunning = true
    cooldownFrame.Visible = true

    if not isCooldownTweenPlaying then
        isCooldownTweenPlaying = true
        pcall(function()
            cooldownPulseTween:Play()
        end)
    end

    local startTime = tick()
    local totalDuration = duration

    while duration > 0 do
        local remaining = totalDuration - (tick() - startTime)
        duration = remaining < 0 and 0 or remaining
        cooldownLabel.Text = string.format("Kiba V3 : %.1fs", duration)
        task.wait(0.1)
    end

    isCooldownRunning = false
    cooldownFrame.Visible = false

    pcall(function()
        cooldownPulseTween:Cancel()
    end)

    isCooldownTweenPlaying = false
end

local infoFrame = Instance.new("Frame")
infoFrame.Name = "MerebennieInfoBox"
infoFrame.Size = UDim2.new(0, 200, 0, 92)
infoFrame.Position = UDim2.new(0.05, 0, 0.12, 0)
infoFrame.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
infoFrame.Parent = mainGui
infoFrame.ZIndex = 10000
infoFrame.Active = true

Instance.new("UICorner", infoFrame).CornerRadius = UDim.new(0, 10)
Instance.new("UIStroke", infoFrame).Transparency = 0.35

local infoTitleLabel = Instance.new("TextLabel")
infoTitleLabel.Name = "InfoTitle"
infoTitleLabel.Size = UDim2.new(1, -40, 0, 24)
infoTitleLabel.Position = UDim2.new(0, 10, 0, 6)
infoTitleLabel.BackgroundTransparency = 1
infoTitleLabel.Text = "Made by Merebennie"
infoTitleLabel.TextColor3 = Color3.fromRGB(30, 30, 30)
infoTitleLabel.Font = Enum.Font.GothamBold
infoTitleLabel.TextSize = 14
infoTitleLabel.TextXAlignment = Enum.TextXAlignment.Left
infoTitleLabel.Parent = infoFrame
infoTitleLabel.ZIndex = 10001

local closeInfoButton = Instance.new("TextButton")
closeInfoButton.Name = "InfoClose"
closeInfoButton.Size = UDim2.new(0, 22, 0, 22)
closeInfoButton.Position = UDim2.new(1, -28, 0, 6)
closeInfoButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
closeInfoButton.Text = "X"
closeInfoButton.Font = Enum.Font.GothamBold
closeInfoButton.TextSize = 14
closeInfoButton.TextColor3 = Color3.new(1, 1, 1)
closeInfoButton.Parent = infoFrame
closeInfoButton.ZIndex = 10002

Instance.new("UICorner", closeInfoButton).CornerRadius = UDim.new(0, 6)

closeInfoButton.MouseButton1Click:Connect(function()
    infoFrame.Visible = false
end)

local infoDescriptionLabel = Instance.new("TextLabel")
infoDescriptionLabel.Name = "InfoDesc"
infoDescriptionLabel.Size = UDim2.new(1, -20, 0, 34)
infoDescriptionLabel.Position = UDim2.new(0, 10, 0, 32)
infoDescriptionLabel.BackgroundTransparency = 1
infoDescriptionLabel.TextWrapped = true
infoDescriptionLabel.Text = "Join our discord for more Scripts!\nhttps://discord.gg/5x4xbPvuSc"
infoDescriptionLabel.TextColor3 = Color3.fromRGB(40, 40, 40)
infoDescriptionLabel.Font = Enum.Font.Gotham
infoDescriptionLabel.TextSize = 12
infoDescriptionLabel.TextXAlignment = Enum.TextXAlignment.Left
infoDescriptionLabel.TextYAlignment = Enum.TextYAlignment.Top
infoDescriptionLabel.Parent = infoFrame
infoDescriptionLabel.ZIndex = 10001

local copyLinkButton = Instance.new("TextButton")
copyLinkButton.Name = "InfoCopy"
copyLinkButton.Size = UDim2.new(0, 96, 0, 26)
copyLinkButton.Position = UDim2.new(0, 10, 1, -34)
copyLinkButton.Text = "Copy Link"
copyLinkButton.Font = Enum.Font.GothamBold
copyLinkButton.TextSize = 12
copyLinkButton.BackgroundColor3 = Color3.fromRGB(30, 136, 229)
copyLinkButton.TextColor3 = Color3.new(1, 1, 1)
copyLinkButton.Parent = infoFrame
copyLinkButton.ZIndex = 10001

Instance.new("UICorner", copyLinkButton).CornerRadius = UDim.new(0, 6)

copyLinkButton.MouseButton1Click:Connect(function()
    pcall(function()
        if setclipboard then
            setclipboard("https://discord.gg/5x4xbPvuSc")
        elseif toclipboard then
            toclipboard("https://discord.gg/5x4xbPvuSc")
        end
    end)
end)

local isInfoBeingDragged = nil
local infoDragInput = nil
local infoDragStart = nil
local infoStartPosition = nil

infoFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then

        isInfoBeingDragged = true
        infoDragStart = input.Position
        infoStartPosition = infoFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isInfoBeingDragged = false
            end
        end)
    end
end)

infoFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement
        or input.UserInputType == Enum.UserInputType.Touch then

        infoDragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == infoDragInput and isInfoBeingDragged and infoStartPosition then
        local delta = input.Position - infoDragStart

        local camera = workspace.CurrentCamera
        local viewportSize = camera and camera.ViewportSize or Vector2.new(1920, 1080)

        local clampedX = math.clamp(
            infoStartPosition.X.Offset + delta.X,
            0,
            math.max(0, viewportSize.X - infoFrame.AbsoluteSize.X)
        )

        local clampedY = math.clamp(
            infoStartPosition.Y.Offset + delta.Y,
            0,
            math.max(0, viewportSize.Y - infoFrame.AbsoluteSize.Y)
        )

        infoFrame.Position = UDim2.new(
            infoStartPosition.X.Scale,
            clampedX,
            infoStartPosition.Y.Scale,
            clampedY
        )
    end
end)

local animationConnections = {}

local function clearAnimationConnections()
    for _, connection in pairs(animationConnections) do
        if connection and connection.Disconnect then
            pcall(function()
                connection:Disconnect()
            end)
        end
    end

    animationConnections = {}
end

local function tryTriggerStickDash()
    if stickDashEnabled and not isCooldownRunning then
        if dashCooldownSeconds <= tick() - lastDashTime then
            lastDashTime = tick()

            task.spawn(function()
                pcall(performStickDash)
            end)

            task.spawn(function()
                startCooldown(cooldownDuration)
            end)
        end
    end
end

local function onAnimationPlayed(animationTrack)
    if not animationTrack then
        return
    end

    local animation = animationTrack.Animation
    if not animation then
        return
    end

    local animationIdString = tostring(animation.AnimationId or "")
    if string.find(animationIdString, "10503381238", 1, true) then
        tryTriggerStickDash()
    end
end

local function bindCharacter(character)
    clearAnimationConnections()

    currentCharacter = character
    currentHumanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid", 5)
    currentRootPart = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 5)

    if currentHumanoid and currentRootPart then
        local successHumanoid, animConn = pcall(function()
            return currentHumanoid.AnimationPlayed:Connect(onAnimationPlayed)
        end)

        if successHumanoid and animConn then
            table.insert(animationConnections, animConn)
        end

        local animator = currentHumanoid:FindFirstChildOfClass("Animator")
        if animator then
            local successAnimator, animatorConn = pcall(function()
                return animator.AnimationPlayed:Connect(onAnimationPlayed)
            end)

            if successAnimator and animatorConn then
                table.insert(animationConnections, animatorConn)
            end
        end

        local descendantConnection = character.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("Animation") then
                local animationIdString = tostring(descendant.AnimationId or "")
                if string.find(animationIdString, "10503381238", 1, true) then
                    tryTriggerStickDash()
                end
            end
        end)

        table.insert(animationConnections, descendantConnection)
    end
end

localPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.1)
    pcall(bindCharacter, character)
end)

if localPlayer.Character then
    pcall(bindCharacter, localPlayer.Character)
end
